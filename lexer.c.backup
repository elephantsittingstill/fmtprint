#include "lexer.h"
#include "buffer.h"
#include "string.h"
#include <stdio.h>
#include <stdlib.h>

#define isalpha( c ) ( ( 'a' <= c && c <= 'z' ) || ( 'A' <= c && c <= 'Z' ) )
#define isnum( c ) ( '0' <= c && c <= '9' )
#define tonum( c ) ( c - '0' )
#define isflag( c )                                                            \
	( ( c == '-' ) || ( c == '0' ) || ( c == '\'' ) ||                         \
	  ( c == 35 ) ) /* 35 for hashtag symbol */

/* void read_fstring( char *fstring, ... ) {
	int i = 0;
	int c = fstring[i];
	State state = TEXT;

	while ( ( c = fstring[i] ) != '\0' ) {
		if ( c == '%' ) {
			printf( "%*c", i + 1, '^' );
			printf( "\nfound %% at char %d\nchar: %c\n", i, fstring[i] );
			changestate( state, START )
		}

		i++;
	}
 } */

void read_fstring( const char *fstring, ... ) {
	va_list args;
	va_start( args, fstring );

	String s = { 0 };
	init_String( &s );

	char *buf = malloc( sizeof( char ) * 8 );

	while ( *fstring ) {
		if ( *fstring == '%' ) {
			FormatToken token = parse_format_token( &fstring );
			render_token( buf, &token, &args );
			append_cstr_String( &s, buf );
		} else {
			/* output_append_char(); */
			append_char_String( &s, *fstring );
		}
		if ( ( *fstring + 1 ) == '\0' )
			append_char_String( &s, *fstring );
		*fstring++;
	}

	puts( s.string );

	free_String( &s );
	free( buf );
}

#if USE_COMPUTED_GOTO
void parse_format_switch( const char *fstring ) {
	FormatToken t = { 0 };

	String s = { 0 };
	init_String( &s );

	State state = STATE_TEXT;

	while ( *fstring ) {
		char c = *fstring;

		switch ( state ) {
		case STATE_TEXT:
			if ( c == '%' ) {
				state = STATE_PERCENT;
				*fstring++;
				break;
			} else {
				append_char_String( &s, c );
			}

			*fstring++;
			break;

		case STATE_PERCENT:
			if ( c == '%' ) {
				append_char_String( &s, c );
				state = STATE_TEXT;
			} else {
				state = STATE_FLAGS;
				continue;
			}

			*fstring++;
			break;

		case STATE_FLAGS:
			if ( isflag( c ) ) {
				append_cstr_String( &s, "[FLAGS]" );
				parse_flags( &t, &fstring );
				state = STATE_WIDTH;
				continue;
			} else {
				state = STATE_WIDTH;
				continue;
			}

		case STATE_WIDTH:
			if ( isnum( c ) ) {
				append_cstr_String( &s, "[WIDTH]" );
				parse_width( &t, &fstring );
				state = STATE_PRECISION;
				continue;
			} else {
				state = STATE_PRECISION;
				continue;
			}

		case STATE_PRECISION:
			if ( c == '.' ) {
				append_cstr_String( &s, "[PRECISION]" );
				parse_precision( &t, &fstring );
				state = STATE_SPECIFIER;
				continue;
			} else {
				state = STATE_SPECIFIER;
				continue;
			}

		case STATE_SPECIFIER:
			t.specifier = c;
			if ( c == 's' ) {
				append_cstr_String( &s, "[STR]" );
			} else if ( c == 'd' ) {
				append_cstr_String( &s, "[INT]" );
			} else {
				append_cstr_String( &s, "[UNKNOWN]" );
			}
			state = STATE_TEXT;
			*fstring++;
			break;
		}
	}

	print_fstring( s.string, s.length );
	free_String( &s );
	printf( "flags: %s\n"
			"width: %d\n"
			"precision: %d\n"
			"specifier: %c\n",
			t.flags, t.width, t.precision, t.specifier );
}
#endif

void print_fstring( const char *s, size_t len ) {
#ifdef WINDOWS
	len = (unsigned int)len;
#endif
	PLATFORM_WRITE( 1, s, len );
}

int render_token( char *buf, FormatToken *token, va_list *args ) {
	/* sprintf's used in this function are merely placeholder */

	int written = 0;
	int value;
	const char *string;

	switch ( token->specifier ) {
	case 's':
		string = va_arg( *args, const char * );
		return sprintf( buf, "%s", string );
	case 'd':
		value = va_arg( *args, int );
		return sprintf( buf, "%d", value );
	default:
		written = sprintf( buf, "<?>" );
		return written;
	}
}

FormatToken parse_format_token( const char **fstring ) {
	FormatToken token = { 0 };
	( *fstring )++;

	while ( **fstring ) {
		char c = **fstring;
		if ( isspec( c ) ) {
			token.specifier = c;
			( *fstring )++;
			break;
		} else {
			break;
		}
	}
	return token;
}

void parse_specifier_token( FormatToken *t, String *s, const char **fstring,
							va_list *args ) {
	int written = 0;
	int value;
	const char *string;

	switch ( **fstring ) {
	case 's':
		string = va_arg( *args, const char * );
		append_cstr_String( s, string );
		return;
	case 'd':
		value = va_arg( *args, int );
		const char *d_string = parse_specifier_d();
		append_cstr_String( s, d_string );
	}
}

/* flags: '-', '0', ''', '#' */
void parse_flags( FormatToken *t, const char **fstring ) {
	int i = 0;
	while ( **fstring ) {
		if ( i > 3 ) {
			fprintf( stderr, "ERROR: flag overflow in formatted string\n" );
			exit( -1 );
		}

		char c = **fstring;

		if ( isflag( c ) ) {
			t->flags[i++] = c;
			( *fstring )++;
		} else {
			break;
		}
	}
	return;
}

/* width: number */
void parse_width( FormatToken *t, const char **fstring ) {
	int result = 0;
	while ( isnum( **fstring ) ) {
		if ( result > 0 ) {
			result += ( ( result * 10 ) + tonum( **fstring ) );
		} else {
			result += tonum( **fstring );
		}

		( *fstring )++;
	}

	t->width = result;
	return;
}

void parse_precision( FormatToken *t, const char **fstring ) {
	int result = 0;
	( *fstring )++;

	while ( isnum( **fstring ) ) {
		if ( result > 0 ) {
			result += ( ( result * 10 ) + tonum( **fstring ) );
		} else {
			result += tonum( **fstring );
		}

		( *fstring )++;
	}

	t->precision = result;
	return;
}

char *parse_specifier_d() { return "penis"; }
